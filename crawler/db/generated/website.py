# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: website.sql
import pydantic
from typing import Any, AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


COUNT_WEBSITES = """-- name: count_websites \\:one
SELECT COUNT(*) FROM website
WHERE status = COALESCE(:p1, status)
"""


CREATE_WEBSITE = """-- name: create_website \\:one
INSERT INTO website (
    name,
    base_url,
    config,
    cron_schedule,
    created_by,
    status
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    :p5,
    :p6
)
RETURNING id, name, base_url, config, status, created_at, updated_at, created_by, cron_schedule, deleted_at
"""


DELETE_WEBSITE = """-- name: delete_website \\:exec
DELETE FROM website
WHERE id = :p1
"""


GET_WEBSITE_BY_ID = """-- name: get_website_by_id \\:one
SELECT id, name, base_url, config, status, created_at, updated_at, created_by, cron_schedule, deleted_at FROM website
WHERE id = :p1
"""


GET_WEBSITE_BY_NAME = """-- name: get_website_by_name \\:one
SELECT id, name, base_url, config, status, created_at, updated_at, created_by, cron_schedule, deleted_at FROM website
WHERE name = :p1
"""


GET_WEBSITE_STATISTICS = """-- name: get_website_statistics \\:one
SELECT
    COALESCE(COUNT(cj.id), 0)\\:\\:INTEGER AS total_jobs,
    COALESCE(COUNT(cj.id) FILTER (WHERE cj.status = 'completed'), 0)\\:\\:INTEGER AS completed_jobs,
    COALESCE(COUNT(cj.id) FILTER (WHERE cj.status = 'failed'), 0)\\:\\:INTEGER AS failed_jobs,
    COALESCE(COUNT(cj.id) FILTER (WHERE cj.status = 'cancelled'), 0)\\:\\:INTEGER AS cancelled_jobs,
    CASE
        WHEN COUNT(cj.id) = 0 THEN 0.0
        ELSE (COUNT(cj.id) FILTER (WHERE cj.status = 'completed')\\:\\:FLOAT / COUNT(cj.id)\\:\\:FLOAT * 100.0)
    END AS success_rate,
    COALESCE(SUM((
        SELECT COUNT(*)
        FROM crawled_page cp
        WHERE cp.job_id = cj.id
    )), 0)\\:\\:INTEGER AS total_pages_crawled,
    MAX(cj.completed_at) FILTER (WHERE cj.status = 'completed') AS last_crawl_at
FROM website w
LEFT JOIN crawl_job cj ON cj.website_id = w.id
WHERE w.id = :p1
GROUP BY w.id
"""


class GetWebsiteStatisticsRow(pydantic.BaseModel):
    total_jobs: int
    completed_jobs: int
    failed_jobs: int
    cancelled_jobs: int
    success_rate: Optional[Any]
    total_pages_crawled: int
    last_crawl_at: Any


LIST_WEBSITES = """-- name: list_websites \\:many
SELECT id, name, base_url, config, status, created_at, updated_at, created_by, cron_schedule, deleted_at FROM website
WHERE status = COALESCE(:p1, status)
ORDER BY created_at DESC
OFFSET :p2 LIMIT :p3
"""


SOFT_DELETE_WEBSITE = """-- name: soft_delete_website \\:one
UPDATE website
SET
    deleted_at = CURRENT_TIMESTAMP,
    status = 'inactive',
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p1
  AND deleted_at IS NULL
RETURNING id, name, base_url, config, status, created_at, updated_at, created_by, cron_schedule, deleted_at
"""


UPDATE_WEBSITE = """-- name: update_website \\:one
UPDATE website
SET
    name = COALESCE(:p1, name),
    base_url = COALESCE(:p2, base_url),
    config = COALESCE(:p3, config),
    cron_schedule = COALESCE(:p4, cron_schedule),
    status = COALESCE(:p5, status),
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p6
RETURNING id, name, base_url, config, status, created_at, updated_at, created_by, cron_schedule, deleted_at
"""


UPDATE_WEBSITE_STATUS = """-- name: update_website_status \\:one
UPDATE website
SET
    status = :p1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p2
RETURNING id, name, base_url, config, status, created_at, updated_at, created_by, cron_schedule, deleted_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def count_websites(self, *, status: models.StatusEnum) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_WEBSITES), {"p1": status})).first()
        if row is None:
            return None
        return row[0]

    async def create_website(self, *, name: str, base_url: str, config: Any, cron_schedule: Optional[str], created_by: Optional[str], status: models.StatusEnum) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_WEBSITE), {
            "p1": name,
            "p2": base_url,
            "p3": config,
            "p4": cron_schedule,
            "p5": created_by,
            "p6": status,
        })).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
            cron_schedule=row[8],
            deleted_at=row[9],
        )

    async def delete_website(self, *, id: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_WEBSITE), {"p1": id})

    async def get_website_by_id(self, *, id: uuid.UUID) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(GET_WEBSITE_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
            cron_schedule=row[8],
            deleted_at=row[9],
        )

    async def get_website_by_name(self, *, name: str) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(GET_WEBSITE_BY_NAME), {"p1": name})).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
            cron_schedule=row[8],
            deleted_at=row[9],
        )

    async def get_website_statistics(self, *, website_id: uuid.UUID) -> Optional[GetWebsiteStatisticsRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_WEBSITE_STATISTICS), {"p1": website_id})).first()
        if row is None:
            return None
        return GetWebsiteStatisticsRow(
            total_jobs=row[0],
            completed_jobs=row[1],
            failed_jobs=row[2],
            cancelled_jobs=row[3],
            success_rate=row[4],
            total_pages_crawled=row[5],
            last_crawl_at=row[6],
        )

    async def list_websites(self, *, status: models.StatusEnum, offset_count: int, limit_count: int) -> AsyncIterator[models.Website]:
        result = await self._conn.stream(sqlalchemy.text(LIST_WEBSITES), {"p1": status, "p2": offset_count, "p3": limit_count})
        async for row in result:
            yield models.Website(
                id=row[0],
                name=row[1],
                base_url=row[2],
                config=row[3],
                status=row[4],
                created_at=row[5],
                updated_at=row[6],
                created_by=row[7],
                cron_schedule=row[8],
                deleted_at=row[9],
            )

    async def soft_delete_website(self, *, id: uuid.UUID) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(SOFT_DELETE_WEBSITE), {"p1": id})).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
            cron_schedule=row[8],
            deleted_at=row[9],
        )

    async def update_website(self, *, name: str, base_url: str, config: Any, cron_schedule: Optional[str], status: models.StatusEnum, id: uuid.UUID) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_WEBSITE), {
            "p1": name,
            "p2": base_url,
            "p3": config,
            "p4": cron_schedule,
            "p5": status,
            "p6": id,
        })).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
            cron_schedule=row[8],
            deleted_at=row[9],
        )

    async def update_website_status(self, *, status: models.StatusEnum, id: uuid.UUID) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_WEBSITE_STATUS), {"p1": status, "p2": id})).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
            cron_schedule=row[8],
            deleted_at=row[9],
        )
