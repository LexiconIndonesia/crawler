# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: website.sql
from typing import Any, AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


COUNT_WEBSITES = """-- name: count_websites \\:one
SELECT COUNT(*) FROM website
WHERE status = COALESCE(:p1, status)
"""


CREATE_WEBSITE = """-- name: create_website \\:one
INSERT INTO website (
    name,
    base_url,
    config,
    created_by,
    status
) VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    COALESCE(:p5, 'active'\\:\\:status_enum)
)
RETURNING id, name, base_url, config, status, created_at, updated_at, created_by
"""


DELETE_WEBSITE = """-- name: delete_website \\:exec
DELETE FROM website
WHERE id = :p1
"""


GET_WEBSITE_BY_ID = """-- name: get_website_by_id \\:one
SELECT id, name, base_url, config, status, created_at, updated_at, created_by FROM website
WHERE id = :p1
"""


GET_WEBSITE_BY_NAME = """-- name: get_website_by_name \\:one
SELECT id, name, base_url, config, status, created_at, updated_at, created_by FROM website
WHERE name = :p1
"""


LIST_WEBSITES = """-- name: list_websites \\:many
SELECT id, name, base_url, config, status, created_at, updated_at, created_by FROM website
WHERE status = COALESCE(:p1, status)
ORDER BY created_at DESC
LIMIT :p3 OFFSET :p2
"""


UPDATE_WEBSITE = """-- name: update_website \\:one
UPDATE website
SET
    name = COALESCE(:p1, name),
    base_url = COALESCE(:p2, base_url),
    config = COALESCE(:p3, config),
    status = COALESCE(:p4, status),
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p5
RETURNING id, name, base_url, config, status, created_at, updated_at, created_by
"""


UPDATE_WEBSITE_STATUS = """-- name: update_website_status \\:one
UPDATE website
SET
    status = :p1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p2
RETURNING id, name, base_url, config, status, created_at, updated_at, created_by
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def count_websites(self, *, status: models.StatusEnum) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_WEBSITES), {"p1": status})).first()
        if row is None:
            return None
        return row[0]

    async def create_website(self, *, name: str, base_url: str, config: Any, created_by: Optional[str], status: Optional[Any]) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_WEBSITE), {
            "p1": name,
            "p2": base_url,
            "p3": config,
            "p4": created_by,
            "p5": status,
        })).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
        )

    async def delete_website(self, *, id: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_WEBSITE), {"p1": id})

    async def get_website_by_id(self, *, id: uuid.UUID) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(GET_WEBSITE_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
        )

    async def get_website_by_name(self, *, name: str) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(GET_WEBSITE_BY_NAME), {"p1": name})).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
        )

    async def list_websites(self, *, status: models.StatusEnum, offset_count: int, limit_count: int) -> AsyncIterator[models.Website]:
        result = await self._conn.stream(sqlalchemy.text(LIST_WEBSITES), {"p1": status, "p2": offset_count, "p3": limit_count})
        async for row in result:
            yield models.Website(
                id=row[0],
                name=row[1],
                base_url=row[2],
                config=row[3],
                status=row[4],
                created_at=row[5],
                updated_at=row[6],
                created_by=row[7],
            )

    async def update_website(self, *, name: str, base_url: str, config: Any, status: models.StatusEnum, id: uuid.UUID) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_WEBSITE), {
            "p1": name,
            "p2": base_url,
            "p3": config,
            "p4": status,
            "p5": id,
        })).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
        )

    async def update_website_status(self, *, status: models.StatusEnum, id: uuid.UUID) -> Optional[models.Website]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_WEBSITE_STATUS), {"p1": status, "p2": id})).first()
        if row is None:
            return None
        return models.Website(
            id=row[0],
            name=row[1],
            base_url=row[2],
            config=row[3],
            status=row[4],
            created_at=row[5],
            updated_at=row[6],
            created_by=row[7],
        )
