# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: content_hash.sql
import pydantic
from typing import Any, AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


DELETE_OLD_CONTENT_HASHES = """-- name: delete_old_content_hashes \\:exec
DELETE FROM content_hash
WHERE last_seen_at < CURRENT_TIMESTAMP - INTERVAL '90 days'
"""


GET_CONTENT_HASH = """-- name: get_content_hash \\:one
SELECT content_hash, first_seen_page_id, occurrence_count, last_seen_at, created_at FROM content_hash
WHERE content_hash = :p1
"""


GET_CONTENT_HASH_STATS = """-- name: get_content_hash_stats \\:one
SELECT
    COUNT(*) as total_hashes,
    SUM(occurrence_count) as total_occurrences,
    AVG(occurrence_count) as avg_occurrences,
    MAX(occurrence_count) as max_occurrences
FROM content_hash
"""


class GetContentHashStatsRow(pydantic.BaseModel):
    total_hashes: int
    total_occurrences: int
    avg_occurrences: float
    max_occurrences: Any


GET_MOST_COMMON_HASHES = """-- name: get_most_common_hashes \\:many
SELECT content_hash, first_seen_page_id, occurrence_count, last_seen_at, created_at FROM content_hash
WHERE occurrence_count > :p1
ORDER BY occurrence_count DESC
LIMIT :p2
"""


LIST_CONTENT_HASHES = """-- name: list_content_hashes \\:many
SELECT content_hash, first_seen_page_id, occurrence_count, last_seen_at, created_at FROM content_hash
ORDER BY occurrence_count DESC
OFFSET :p1 LIMIT :p2
"""


UPSERT_CONTENT_HASH = """-- name: upsert_content_hash \\:one
INSERT INTO content_hash (
    content_hash,
    first_seen_page_id,
    occurrence_count,
    last_seen_at
) VALUES (
    :p1,
    :p2,
    1,
    CURRENT_TIMESTAMP
)
ON CONFLICT (content_hash)
DO UPDATE SET
    occurrence_count = content_hash.occurrence_count + 1,
    last_seen_at = CURRENT_TIMESTAMP
RETURNING content_hash, first_seen_page_id, occurrence_count, last_seen_at, created_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def delete_old_content_hashes(self) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_OLD_CONTENT_HASHES))

    async def get_content_hash(self, *, content_hash: str) -> Optional[models.ContentHash]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CONTENT_HASH), {"p1": content_hash})).first()
        if row is None:
            return None
        return models.ContentHash(
            content_hash=row[0],
            first_seen_page_id=row[1],
            occurrence_count=row[2],
            last_seen_at=row[3],
            created_at=row[4],
        )

    async def get_content_hash_stats(self) -> Optional[GetContentHashStatsRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CONTENT_HASH_STATS))).first()
        if row is None:
            return None
        return GetContentHashStatsRow(
            total_hashes=row[0],
            total_occurrences=row[1],
            avg_occurrences=row[2],
            max_occurrences=row[3],
        )

    async def get_most_common_hashes(self, *, min_count: int, limit_count: int) -> AsyncIterator[models.ContentHash]:
        result = await self._conn.stream(sqlalchemy.text(GET_MOST_COMMON_HASHES), {"p1": min_count, "p2": limit_count})
        async for row in result:
            yield models.ContentHash(
                content_hash=row[0],
                first_seen_page_id=row[1],
                occurrence_count=row[2],
                last_seen_at=row[3],
                created_at=row[4],
            )

    async def list_content_hashes(self, *, offset_count: int, limit_count: int) -> AsyncIterator[models.ContentHash]:
        result = await self._conn.stream(sqlalchemy.text(LIST_CONTENT_HASHES), {"p1": offset_count, "p2": limit_count})
        async for row in result:
            yield models.ContentHash(
                content_hash=row[0],
                first_seen_page_id=row[1],
                occurrence_count=row[2],
                last_seen_at=row[3],
                created_at=row[4],
            )

    async def upsert_content_hash(self, *, content_hash: str, first_seen_page_id: Optional[uuid.UUID]) -> Optional[models.ContentHash]:
        row = (await self._conn.execute(sqlalchemy.text(UPSERT_CONTENT_HASH), {"p1": content_hash, "p2": first_seen_page_id})).first()
        if row is None:
            return None
        return models.ContentHash(
            content_hash=row[0],
            first_seen_page_id=row[1],
            occurrence_count=row[2],
            last_seen_at=row[3],
            created_at=row[4],
        )
