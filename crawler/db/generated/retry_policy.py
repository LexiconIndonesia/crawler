# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: retry_policy.sql
from typing import AsyncIterator, Optional

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


GET_RETRY_POLICY_BY_CATEGORY = """-- name: get_retry_policy_by_category \\:one
SELECT id, error_category, is_retryable, max_attempts, backoff_strategy, initial_delay_seconds, max_delay_seconds, backoff_multiplier, description, created_at, updated_at FROM retry_policy
WHERE error_category = :p1
"""


LIST_ALL_RETRY_POLICIES = """-- name: list_all_retry_policies \\:many
SELECT id, error_category, is_retryable, max_attempts, backoff_strategy, initial_delay_seconds, max_delay_seconds, backoff_multiplier, description, created_at, updated_at FROM retry_policy
ORDER BY error_category
"""


LIST_RETRYABLE_POLICIES = """-- name: list_retryable_policies \\:many
SELECT id, error_category, is_retryable, max_attempts, backoff_strategy, initial_delay_seconds, max_delay_seconds, backoff_multiplier, description, created_at, updated_at FROM retry_policy
WHERE is_retryable = true
ORDER BY error_category
"""


UPDATE_RETRY_POLICY = """-- name: update_retry_policy \\:one
UPDATE retry_policy
SET
    is_retryable = COALESCE(:p2, is_retryable),
    max_attempts = COALESCE(:p3, max_attempts),
    backoff_strategy = COALESCE(:p4, backoff_strategy),
    initial_delay_seconds = COALESCE(:p5, initial_delay_seconds),
    max_delay_seconds = COALESCE(:p6, max_delay_seconds),
    backoff_multiplier = COALESCE(:p7, backoff_multiplier),
    description = COALESCE(:p8, description),
    updated_at = CURRENT_TIMESTAMP
WHERE error_category = :p1
RETURNING id, error_category, is_retryable, max_attempts, backoff_strategy, initial_delay_seconds, max_delay_seconds, backoff_multiplier, description, created_at, updated_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def get_retry_policy_by_category(self, *, error_category: models.ErrorCategoryEnum) -> Optional[models.RetryPolicy]:
        row = (await self._conn.execute(sqlalchemy.text(GET_RETRY_POLICY_BY_CATEGORY), {"p1": error_category})).first()
        if row is None:
            return None
        return models.RetryPolicy(
            id=row[0],
            error_category=row[1],
            is_retryable=row[2],
            max_attempts=row[3],
            backoff_strategy=row[4],
            initial_delay_seconds=row[5],
            max_delay_seconds=row[6],
            backoff_multiplier=row[7],
            description=row[8],
            created_at=row[9],
            updated_at=row[10],
        )

    async def list_all_retry_policies(self) -> AsyncIterator[models.RetryPolicy]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ALL_RETRY_POLICIES))
        async for row in result:
            yield models.RetryPolicy(
                id=row[0],
                error_category=row[1],
                is_retryable=row[2],
                max_attempts=row[3],
                backoff_strategy=row[4],
                initial_delay_seconds=row[5],
                max_delay_seconds=row[6],
                backoff_multiplier=row[7],
                description=row[8],
                created_at=row[9],
                updated_at=row[10],
            )

    async def list_retryable_policies(self) -> AsyncIterator[models.RetryPolicy]:
        result = await self._conn.stream(sqlalchemy.text(LIST_RETRYABLE_POLICIES))
        async for row in result:
            yield models.RetryPolicy(
                id=row[0],
                error_category=row[1],
                is_retryable=row[2],
                max_attempts=row[3],
                backoff_strategy=row[4],
                initial_delay_seconds=row[5],
                max_delay_seconds=row[6],
                backoff_multiplier=row[7],
                description=row[8],
                created_at=row[9],
                updated_at=row[10],
            )

    async def update_retry_policy(self, *, error_category: models.ErrorCategoryEnum, is_retryable: bool, max_attempts: int, backoff_strategy: models.BackoffStrategyEnum, initial_delay_seconds: int, max_delay_seconds: int, backoff_multiplier: float, description: Optional[str]) -> Optional[models.RetryPolicy]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_RETRY_POLICY), {
            "p1": error_category,
            "p2": is_retryable,
            "p3": max_attempts,
            "p4": backoff_strategy,
            "p5": initial_delay_seconds,
            "p6": max_delay_seconds,
            "p7": backoff_multiplier,
            "p8": description,
        })).first()
        if row is None:
            return None
        return models.RetryPolicy(
            id=row[0],
            error_category=row[1],
            is_retryable=row[2],
            max_attempts=row[3],
            backoff_strategy=row[4],
            initial_delay_seconds=row[5],
            max_delay_seconds=row[6],
            backoff_multiplier=row[7],
            description=row[8],
            created_at=row[9],
            updated_at=row[10],
        )
