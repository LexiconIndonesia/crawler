# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.29.0
# source: crawl_job.sql
import datetime
from typing import Any, AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


CANCEL_CRAWL_JOB = """-- name: cancel_crawl_job \\:one
UPDATE crawl_job
SET
    status = 'cancelled',
    cancelled_at = CURRENT_TIMESTAMP,
    cancelled_by = :p1,
    cancellation_reason = :p2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p3
RETURNING id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at
"""


COUNT_CRAWL_JOBS = """-- name: count_crawl_jobs \\:one
SELECT COUNT(*) FROM crawl_job
WHERE
    website_id = COALESCE(:p1, website_id)
    AND status = COALESCE(:p2, status)
"""


CREATE_CRAWL_JOB = """-- name: create_crawl_job \\:one
INSERT INTO crawl_job (
    website_id,
    job_type,
    seed_url,
    embedded_config,
    priority,
    scheduled_at,
    max_retries,
    metadata,
    variables
) VALUES (
    :p1,
    COALESCE(:p2, 'one_time'\\:\\:job_type_enum),
    :p3,
    :p4,
    COALESCE(:p5, 5),
    :p6,
    COALESCE(:p7, 3),
    :p8,
    :p9
)
RETURNING id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at
"""


DELETE_OLD_COMPLETED_JOBS = """-- name: delete_old_completed_jobs \\:exec
DELETE FROM crawl_job
WHERE status IN ('completed', 'cancelled')
    AND completed_at < CURRENT_TIMESTAMP - INTERVAL '30 days'
"""


GET_CRAWL_JOB_BY_ID = """-- name: get_crawl_job_by_id \\:one
SELECT id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at FROM crawl_job
WHERE id = :p1
"""


GET_FAILED_JOBS_FOR_RETRY = """-- name: get_failed_jobs_for_retry \\:many
SELECT id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at FROM crawl_job
WHERE status = 'failed'
    AND retry_count < max_retries
ORDER BY priority DESC, created_at ASC
LIMIT :p1
"""


GET_JOBS_BY_WEBSITE = """-- name: get_jobs_by_website \\:many
SELECT id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at FROM crawl_job
WHERE website_id = :p1
ORDER BY created_at DESC
LIMIT :p3 OFFSET :p2
"""


GET_PENDING_JOBS = """-- name: get_pending_jobs \\:many
SELECT id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at FROM crawl_job
WHERE status = 'pending'
    AND (scheduled_at IS NULL OR scheduled_at <= CURRENT_TIMESTAMP)
ORDER BY priority DESC, created_at ASC
LIMIT :p1
"""


GET_RUNNING_JOBS = """-- name: get_running_jobs \\:many
SELECT id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at FROM crawl_job
WHERE status = 'running'
ORDER BY started_at ASC
"""


INCREMENT_JOB_RETRY_COUNT = """-- name: increment_job_retry_count \\:one
UPDATE crawl_job
SET
    retry_count = retry_count + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p1
RETURNING id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at
"""


LIST_CRAWL_JOBS = """-- name: list_crawl_jobs \\:many
SELECT id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at FROM crawl_job
WHERE
    website_id = COALESCE(:p1, website_id)
    AND status = COALESCE(:p2, status)
    AND job_type = COALESCE(:p3, job_type)
ORDER BY priority DESC, created_at ASC
LIMIT :p5 OFFSET :p4
"""


UPDATE_CRAWL_JOB_PROGRESS = """-- name: update_crawl_job_progress \\:one
UPDATE crawl_job
SET
    progress = :p1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p2
RETURNING id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at
"""


UPDATE_CRAWL_JOB_STATUS = """-- name: update_crawl_job_status \\:one
UPDATE crawl_job
SET
    status = :p1\\:\\:status_enum,
    started_at = CASE WHEN :p1\\:\\:status_enum = 'running'\\:\\:status_enum THEN COALESCE(:p2, CURRENT_TIMESTAMP) ELSE started_at END,
    completed_at = CASE WHEN :p1\\:\\:status_enum IN ('completed'\\:\\:status_enum, 'failed'\\:\\:status_enum, 'cancelled'\\:\\:status_enum) THEN COALESCE(:p3, CURRENT_TIMESTAMP) ELSE completed_at END,
    error_message = :p4,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p5
RETURNING id, website_id, job_type, seed_url, embedded_config, status, priority, scheduled_at, started_at, completed_at, cancelled_at, cancelled_by, cancellation_reason, error_message, retry_count, max_retries, metadata, variables, progress, created_at, updated_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def cancel_crawl_job(self, *, cancelled_by: Optional[str], cancellation_reason: Optional[str], id: uuid.UUID) -> Optional[models.CrawlJob]:
        row = (await self._conn.execute(sqlalchemy.text(CANCEL_CRAWL_JOB), {"p1": cancelled_by, "p2": cancellation_reason, "p3": id})).first()
        if row is None:
            return None
        return models.CrawlJob(
            id=row[0],
            website_id=row[1],
            job_type=row[2],
            seed_url=row[3],
            embedded_config=row[4],
            status=row[5],
            priority=row[6],
            scheduled_at=row[7],
            started_at=row[8],
            completed_at=row[9],
            cancelled_at=row[10],
            cancelled_by=row[11],
            cancellation_reason=row[12],
            error_message=row[13],
            retry_count=row[14],
            max_retries=row[15],
            metadata=row[16],
            variables=row[17],
            progress=row[18],
            created_at=row[19],
            updated_at=row[20],
        )

    async def count_crawl_jobs(self, *, website_id: uuid.UUID, status: models.StatusEnum) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_CRAWL_JOBS), {"p1": website_id, "p2": status})).first()
        if row is None:
            return None
        return row[0]

    async def create_crawl_job(self, *, website_id: uuid.UUID, job_type: Optional[Any], seed_url: str, embedded_config: Optional[Any], priority: Optional[Any], scheduled_at: Optional[datetime.datetime], max_retries: Optional[Any], metadata: Optional[Any], variables: Optional[Any]) -> Optional[models.CrawlJob]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_CRAWL_JOB), {
            "p1": website_id,
            "p2": job_type,
            "p3": seed_url,
            "p4": embedded_config,
            "p5": priority,
            "p6": scheduled_at,
            "p7": max_retries,
            "p8": metadata,
            "p9": variables,
        })).first()
        if row is None:
            return None
        return models.CrawlJob(
            id=row[0],
            website_id=row[1],
            job_type=row[2],
            seed_url=row[3],
            embedded_config=row[4],
            status=row[5],
            priority=row[6],
            scheduled_at=row[7],
            started_at=row[8],
            completed_at=row[9],
            cancelled_at=row[10],
            cancelled_by=row[11],
            cancellation_reason=row[12],
            error_message=row[13],
            retry_count=row[14],
            max_retries=row[15],
            metadata=row[16],
            variables=row[17],
            progress=row[18],
            created_at=row[19],
            updated_at=row[20],
        )

    async def delete_old_completed_jobs(self) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_OLD_COMPLETED_JOBS))

    async def get_crawl_job_by_id(self, *, id: uuid.UUID) -> Optional[models.CrawlJob]:
        row = (await self._conn.execute(sqlalchemy.text(GET_CRAWL_JOB_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.CrawlJob(
            id=row[0],
            website_id=row[1],
            job_type=row[2],
            seed_url=row[3],
            embedded_config=row[4],
            status=row[5],
            priority=row[6],
            scheduled_at=row[7],
            started_at=row[8],
            completed_at=row[9],
            cancelled_at=row[10],
            cancelled_by=row[11],
            cancellation_reason=row[12],
            error_message=row[13],
            retry_count=row[14],
            max_retries=row[15],
            metadata=row[16],
            variables=row[17],
            progress=row[18],
            created_at=row[19],
            updated_at=row[20],
        )

    async def get_failed_jobs_for_retry(self, *, limit_count: int) -> AsyncIterator[models.CrawlJob]:
        result = await self._conn.stream(sqlalchemy.text(GET_FAILED_JOBS_FOR_RETRY), {"p1": limit_count})
        async for row in result:
            yield models.CrawlJob(
                id=row[0],
                website_id=row[1],
                job_type=row[2],
                seed_url=row[3],
                embedded_config=row[4],
                status=row[5],
                priority=row[6],
                scheduled_at=row[7],
                started_at=row[8],
                completed_at=row[9],
                cancelled_at=row[10],
                cancelled_by=row[11],
                cancellation_reason=row[12],
                error_message=row[13],
                retry_count=row[14],
                max_retries=row[15],
                metadata=row[16],
                variables=row[17],
                progress=row[18],
                created_at=row[19],
                updated_at=row[20],
            )

    async def get_jobs_by_website(self, *, website_id: uuid.UUID, offset_count: int, limit_count: int) -> AsyncIterator[models.CrawlJob]:
        result = await self._conn.stream(sqlalchemy.text(GET_JOBS_BY_WEBSITE), {"p1": website_id, "p2": offset_count, "p3": limit_count})
        async for row in result:
            yield models.CrawlJob(
                id=row[0],
                website_id=row[1],
                job_type=row[2],
                seed_url=row[3],
                embedded_config=row[4],
                status=row[5],
                priority=row[6],
                scheduled_at=row[7],
                started_at=row[8],
                completed_at=row[9],
                cancelled_at=row[10],
                cancelled_by=row[11],
                cancellation_reason=row[12],
                error_message=row[13],
                retry_count=row[14],
                max_retries=row[15],
                metadata=row[16],
                variables=row[17],
                progress=row[18],
                created_at=row[19],
                updated_at=row[20],
            )

    async def get_pending_jobs(self, *, limit_count: int) -> AsyncIterator[models.CrawlJob]:
        result = await self._conn.stream(sqlalchemy.text(GET_PENDING_JOBS), {"p1": limit_count})
        async for row in result:
            yield models.CrawlJob(
                id=row[0],
                website_id=row[1],
                job_type=row[2],
                seed_url=row[3],
                embedded_config=row[4],
                status=row[5],
                priority=row[6],
                scheduled_at=row[7],
                started_at=row[8],
                completed_at=row[9],
                cancelled_at=row[10],
                cancelled_by=row[11],
                cancellation_reason=row[12],
                error_message=row[13],
                retry_count=row[14],
                max_retries=row[15],
                metadata=row[16],
                variables=row[17],
                progress=row[18],
                created_at=row[19],
                updated_at=row[20],
            )

    async def get_running_jobs(self) -> AsyncIterator[models.CrawlJob]:
        result = await self._conn.stream(sqlalchemy.text(GET_RUNNING_JOBS))
        async for row in result:
            yield models.CrawlJob(
                id=row[0],
                website_id=row[1],
                job_type=row[2],
                seed_url=row[3],
                embedded_config=row[4],
                status=row[5],
                priority=row[6],
                scheduled_at=row[7],
                started_at=row[8],
                completed_at=row[9],
                cancelled_at=row[10],
                cancelled_by=row[11],
                cancellation_reason=row[12],
                error_message=row[13],
                retry_count=row[14],
                max_retries=row[15],
                metadata=row[16],
                variables=row[17],
                progress=row[18],
                created_at=row[19],
                updated_at=row[20],
            )

    async def increment_job_retry_count(self, *, id: uuid.UUID) -> Optional[models.CrawlJob]:
        row = (await self._conn.execute(sqlalchemy.text(INCREMENT_JOB_RETRY_COUNT), {"p1": id})).first()
        if row is None:
            return None
        return models.CrawlJob(
            id=row[0],
            website_id=row[1],
            job_type=row[2],
            seed_url=row[3],
            embedded_config=row[4],
            status=row[5],
            priority=row[6],
            scheduled_at=row[7],
            started_at=row[8],
            completed_at=row[9],
            cancelled_at=row[10],
            cancelled_by=row[11],
            cancellation_reason=row[12],
            error_message=row[13],
            retry_count=row[14],
            max_retries=row[15],
            metadata=row[16],
            variables=row[17],
            progress=row[18],
            created_at=row[19],
            updated_at=row[20],
        )

    async def list_crawl_jobs(self, *, website_id: uuid.UUID, status: models.StatusEnum, job_type: models.JobTypeEnum, offset_count: int, limit_count: int) -> AsyncIterator[models.CrawlJob]:
        result = await self._conn.stream(sqlalchemy.text(LIST_CRAWL_JOBS), {
            "p1": website_id,
            "p2": status,
            "p3": job_type,
            "p4": offset_count,
            "p5": limit_count,
        })
        async for row in result:
            yield models.CrawlJob(
                id=row[0],
                website_id=row[1],
                job_type=row[2],
                seed_url=row[3],
                embedded_config=row[4],
                status=row[5],
                priority=row[6],
                scheduled_at=row[7],
                started_at=row[8],
                completed_at=row[9],
                cancelled_at=row[10],
                cancelled_by=row[11],
                cancellation_reason=row[12],
                error_message=row[13],
                retry_count=row[14],
                max_retries=row[15],
                metadata=row[16],
                variables=row[17],
                progress=row[18],
                created_at=row[19],
                updated_at=row[20],
            )

    async def update_crawl_job_progress(self, *, progress: Optional[Any], id: uuid.UUID) -> Optional[models.CrawlJob]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_CRAWL_JOB_PROGRESS), {"p1": progress, "p2": id})).first()
        if row is None:
            return None
        return models.CrawlJob(
            id=row[0],
            website_id=row[1],
            job_type=row[2],
            seed_url=row[3],
            embedded_config=row[4],
            status=row[5],
            priority=row[6],
            scheduled_at=row[7],
            started_at=row[8],
            completed_at=row[9],
            cancelled_at=row[10],
            cancelled_by=row[11],
            cancellation_reason=row[12],
            error_message=row[13],
            retry_count=row[14],
            max_retries=row[15],
            metadata=row[16],
            variables=row[17],
            progress=row[18],
            created_at=row[19],
            updated_at=row[20],
        )

    async def update_crawl_job_status(self, *, status: models.StatusEnum, started_at: Optional[datetime.datetime], completed_at: Optional[datetime.datetime], error_message: Optional[str], id: uuid.UUID) -> Optional[models.CrawlJob]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_CRAWL_JOB_STATUS), {
            "p1": status,
            "p2": started_at,
            "p3": completed_at,
            "p4": error_message,
            "p5": id,
        })).first()
        if row is None:
            return None
        return models.CrawlJob(
            id=row[0],
            website_id=row[1],
            job_type=row[2],
            seed_url=row[3],
            embedded_config=row[4],
            status=row[5],
            priority=row[6],
            scheduled_at=row[7],
            started_at=row[8],
            completed_at=row[9],
            cancelled_at=row[10],
            cancelled_by=row[11],
            cancellation_reason=row[12],
            error_message=row[13],
            retry_count=row[14],
            max_retries=row[15],
            metadata=row[16],
            variables=row[17],
            progress=row[18],
            created_at=row[19],
            updated_at=row[20],
        )
