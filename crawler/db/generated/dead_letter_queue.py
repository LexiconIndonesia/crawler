# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: dead_letter_queue.sql
import datetime
import pydantic
from typing import AsyncIterator, List, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


ADD_TO_DEAD_LETTER_QUEUE = """-- name: add_to_dead_letter_queue \\:one

INSERT INTO dead_letter_queue (
    job_id,
    seed_url,
    website_id,
    job_type,
    priority,
    error_category,
    error_message,
    stack_trace,
    http_status,
    total_attempts,
    first_attempt_at,
    last_attempt_at
) VALUES (
    :p1, :p2, :p3, :p4, :p5, :p6, :p7, :p8, :p9, :p10, :p11, :p12
) RETURNING id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes
"""


class AddToDeadLetterQueueParams(pydantic.BaseModel):
    job_id: uuid.UUID
    seed_url: str
    website_id: Optional[uuid.UUID]
    job_type: models.JobTypeEnum
    priority: int
    error_category: models.ErrorCategoryEnum
    error_message: str
    stack_trace: Optional[str]
    http_status: Optional[int]
    total_attempts: int
    first_attempt_at: datetime.datetime
    last_attempt_at: datetime.datetime


BULK_MARK_DLQ_RESOLVED = """-- name: bulk_mark_dlq_resolved \\:exec
UPDATE dead_letter_queue
SET
    resolved_at = CURRENT_TIMESTAMP,
    resolution_notes = :p2
WHERE id = ANY(:p1\\:\\:BIGINT[])
"""


COUNT_DLQ_ENTRIES = """-- name: count_dlq_entries \\:one
SELECT COUNT(*) FROM dead_letter_queue
WHERE (:p1\\:\\:error_category_enum IS NULL OR error_category = :p1)
  AND (:p2\\:\\:uuid IS NULL OR website_id = :p2)
  AND (:p3\\:\\:boolean IS NULL OR
       (:p3 = true AND resolved_at IS NULL) OR
       (:p3 = false AND resolved_at IS NOT NULL))
"""


DELETE_DLQ_ENTRY = """-- name: delete_dlq_entry \\:exec
DELETE FROM dead_letter_queue
WHERE id = :p1
"""


GET_DLQ_ENTRIES_FOR_WEBSITE = """-- name: get_dlq_entries_for_website \\:many
SELECT id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes FROM dead_letter_queue
WHERE website_id = :p1
ORDER BY added_to_dlq_at DESC
LIMIT :p2 OFFSET :p3
"""


GET_DLQ_ENTRY_BY_ID = """-- name: get_dlq_entry_by_id \\:one
SELECT id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes FROM dead_letter_queue
WHERE id = :p1
"""


GET_DLQ_ENTRY_BY_JOB_ID = """-- name: get_dlq_entry_by_job_id \\:one
SELECT id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes FROM dead_letter_queue
WHERE job_id = :p1
"""


GET_DLQ_STATS = """-- name: get_dlq_stats \\:one
SELECT
    COUNT(*) as total_entries,
    COUNT(*) FILTER (WHERE resolved_at IS NULL) as unresolved_count,
    COUNT(*) FILTER (WHERE retry_attempted = true) as retry_attempted_count,
    COUNT(*) FILTER (WHERE retry_success = true) as retry_success_count
FROM dead_letter_queue
"""


class GetDLQStatsRow(pydantic.BaseModel):
    total_entries: int
    unresolved_count: int
    retry_attempted_count: int
    retry_success_count: int


GET_DLQ_STATS_BY_CATEGORY = """-- name: get_dlq_stats_by_category \\:many
SELECT
    error_category,
    COUNT(*) as entry_count,
    COUNT(*) FILTER (WHERE resolved_at IS NULL) as unresolved_count
FROM dead_letter_queue
GROUP BY error_category
ORDER BY entry_count DESC
"""


class GetDLQStatsByCategoryRow(pydantic.BaseModel):
    error_category: models.ErrorCategoryEnum
    entry_count: int
    unresolved_count: int


GET_OLDEST_UNRESOLVED_DLQ_ENTRIES = """-- name: get_oldest_unresolved_dlq_entries \\:many
SELECT id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes FROM dead_letter_queue
WHERE resolved_at IS NULL
ORDER BY added_to_dlq_at ASC
LIMIT :p1
"""


LIST_DLQ_ENTRIES = """-- name: list_dlq_entries \\:many
SELECT id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes FROM dead_letter_queue
WHERE (:p1\\:\\:error_category_enum IS NULL OR error_category = :p1)
  AND (:p2\\:\\:uuid IS NULL OR website_id = :p2)
  AND (:p3\\:\\:boolean IS NULL OR
       (:p3 = true AND resolved_at IS NULL) OR
       (:p3 = false AND resolved_at IS NOT NULL))
ORDER BY added_to_dlq_at DESC
LIMIT :p4 OFFSET :p5
"""


MARK_DLQ_RESOLVED = """-- name: mark_dlq_resolved \\:one
UPDATE dead_letter_queue
SET
    resolved_at = CURRENT_TIMESTAMP,
    resolution_notes = :p2
WHERE id = :p1
RETURNING id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes
"""


MARK_DLQ_RETRY_ATTEMPTED = """-- name: mark_dlq_retry_attempted \\:one
UPDATE dead_letter_queue
SET
    retry_attempted = true,
    retry_attempted_at = CURRENT_TIMESTAMP,
    retry_success = :p2
WHERE id = :p1
RETURNING id, job_id, seed_url, website_id, job_type, priority, error_category, error_message, stack_trace, http_status, total_attempts, first_attempt_at, last_attempt_at, added_to_dlq_at, retry_attempted, retry_attempted_at, retry_success, resolved_at, resolution_notes
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def add_to_dead_letter_queue(self, arg: AddToDeadLetterQueueParams) -> Optional[models.DeadLetterQueue]:
        row = (await self._conn.execute(sqlalchemy.text(ADD_TO_DEAD_LETTER_QUEUE), {
            "p1": arg.job_id,
            "p2": arg.seed_url,
            "p3": arg.website_id,
            "p4": arg.job_type,
            "p5": arg.priority,
            "p6": arg.error_category,
            "p7": arg.error_message,
            "p8": arg.stack_trace,
            "p9": arg.http_status,
            "p10": arg.total_attempts,
            "p11": arg.first_attempt_at,
            "p12": arg.last_attempt_at,
        })).first()
        if row is None:
            return None
        return models.DeadLetterQueue(
            id=row[0],
            job_id=row[1],
            seed_url=row[2],
            website_id=row[3],
            job_type=row[4],
            priority=row[5],
            error_category=row[6],
            error_message=row[7],
            stack_trace=row[8],
            http_status=row[9],
            total_attempts=row[10],
            first_attempt_at=row[11],
            last_attempt_at=row[12],
            added_to_dlq_at=row[13],
            retry_attempted=row[14],
            retry_attempted_at=row[15],
            retry_success=row[16],
            resolved_at=row[17],
            resolution_notes=row[18],
        )

    async def bulk_mark_dlq_resolved(self, *, dollar_1: List[int], resolution_notes: Optional[str]) -> None:
        await self._conn.execute(sqlalchemy.text(BULK_MARK_DLQ_RESOLVED), {"p1": dollar_1, "p2": resolution_notes})

    async def count_dlq_entries(self, *, dollar_1: models.ErrorCategoryEnum, dollar_2: uuid.UUID, dollar_3: bool) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_DLQ_ENTRIES), {"p1": dollar_1, "p2": dollar_2, "p3": dollar_3})).first()
        if row is None:
            return None
        return row[0]

    async def delete_dlq_entry(self, *, id: int) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_DLQ_ENTRY), {"p1": id})

    async def get_dlq_entries_for_website(self, *, website_id: Optional[uuid.UUID], limit: int, offset: int) -> AsyncIterator[models.DeadLetterQueue]:
        result = await self._conn.stream(sqlalchemy.text(GET_DLQ_ENTRIES_FOR_WEBSITE), {"p1": website_id, "p2": limit, "p3": offset})
        async for row in result:
            yield models.DeadLetterQueue(
                id=row[0],
                job_id=row[1],
                seed_url=row[2],
                website_id=row[3],
                job_type=row[4],
                priority=row[5],
                error_category=row[6],
                error_message=row[7],
                stack_trace=row[8],
                http_status=row[9],
                total_attempts=row[10],
                first_attempt_at=row[11],
                last_attempt_at=row[12],
                added_to_dlq_at=row[13],
                retry_attempted=row[14],
                retry_attempted_at=row[15],
                retry_success=row[16],
                resolved_at=row[17],
                resolution_notes=row[18],
            )

    async def get_dlq_entry_by_id(self, *, id: int) -> Optional[models.DeadLetterQueue]:
        row = (await self._conn.execute(sqlalchemy.text(GET_DLQ_ENTRY_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.DeadLetterQueue(
            id=row[0],
            job_id=row[1],
            seed_url=row[2],
            website_id=row[3],
            job_type=row[4],
            priority=row[5],
            error_category=row[6],
            error_message=row[7],
            stack_trace=row[8],
            http_status=row[9],
            total_attempts=row[10],
            first_attempt_at=row[11],
            last_attempt_at=row[12],
            added_to_dlq_at=row[13],
            retry_attempted=row[14],
            retry_attempted_at=row[15],
            retry_success=row[16],
            resolved_at=row[17],
            resolution_notes=row[18],
        )

    async def get_dlq_entry_by_job_id(self, *, job_id: uuid.UUID) -> Optional[models.DeadLetterQueue]:
        row = (await self._conn.execute(sqlalchemy.text(GET_DLQ_ENTRY_BY_JOB_ID), {"p1": job_id})).first()
        if row is None:
            return None
        return models.DeadLetterQueue(
            id=row[0],
            job_id=row[1],
            seed_url=row[2],
            website_id=row[3],
            job_type=row[4],
            priority=row[5],
            error_category=row[6],
            error_message=row[7],
            stack_trace=row[8],
            http_status=row[9],
            total_attempts=row[10],
            first_attempt_at=row[11],
            last_attempt_at=row[12],
            added_to_dlq_at=row[13],
            retry_attempted=row[14],
            retry_attempted_at=row[15],
            retry_success=row[16],
            resolved_at=row[17],
            resolution_notes=row[18],
        )

    async def get_dlq_stats(self) -> Optional[GetDLQStatsRow]:
        row = (await self._conn.execute(sqlalchemy.text(GET_DLQ_STATS))).first()
        if row is None:
            return None
        return GetDLQStatsRow(
            total_entries=row[0],
            unresolved_count=row[1],
            retry_attempted_count=row[2],
            retry_success_count=row[3],
        )

    async def get_dlq_stats_by_category(self) -> AsyncIterator[GetDLQStatsByCategoryRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_DLQ_STATS_BY_CATEGORY))
        async for row in result:
            yield GetDLQStatsByCategoryRow(
                error_category=row[0],
                entry_count=row[1],
                unresolved_count=row[2],
            )

    async def get_oldest_unresolved_dlq_entries(self, *, limit: int) -> AsyncIterator[models.DeadLetterQueue]:
        result = await self._conn.stream(sqlalchemy.text(GET_OLDEST_UNRESOLVED_DLQ_ENTRIES), {"p1": limit})
        async for row in result:
            yield models.DeadLetterQueue(
                id=row[0],
                job_id=row[1],
                seed_url=row[2],
                website_id=row[3],
                job_type=row[4],
                priority=row[5],
                error_category=row[6],
                error_message=row[7],
                stack_trace=row[8],
                http_status=row[9],
                total_attempts=row[10],
                first_attempt_at=row[11],
                last_attempt_at=row[12],
                added_to_dlq_at=row[13],
                retry_attempted=row[14],
                retry_attempted_at=row[15],
                retry_success=row[16],
                resolved_at=row[17],
                resolution_notes=row[18],
            )

    async def list_dlq_entries(self, *, dollar_1: models.ErrorCategoryEnum, dollar_2: uuid.UUID, dollar_3: bool, limit: int, offset: int) -> AsyncIterator[models.DeadLetterQueue]:
        result = await self._conn.stream(sqlalchemy.text(LIST_DLQ_ENTRIES), {
            "p1": dollar_1,
            "p2": dollar_2,
            "p3": dollar_3,
            "p4": limit,
            "p5": offset,
        })
        async for row in result:
            yield models.DeadLetterQueue(
                id=row[0],
                job_id=row[1],
                seed_url=row[2],
                website_id=row[3],
                job_type=row[4],
                priority=row[5],
                error_category=row[6],
                error_message=row[7],
                stack_trace=row[8],
                http_status=row[9],
                total_attempts=row[10],
                first_attempt_at=row[11],
                last_attempt_at=row[12],
                added_to_dlq_at=row[13],
                retry_attempted=row[14],
                retry_attempted_at=row[15],
                retry_success=row[16],
                resolved_at=row[17],
                resolution_notes=row[18],
            )

    async def mark_dlq_resolved(self, *, id: int, resolution_notes: Optional[str]) -> Optional[models.DeadLetterQueue]:
        row = (await self._conn.execute(sqlalchemy.text(MARK_DLQ_RESOLVED), {"p1": id, "p2": resolution_notes})).first()
        if row is None:
            return None
        return models.DeadLetterQueue(
            id=row[0],
            job_id=row[1],
            seed_url=row[2],
            website_id=row[3],
            job_type=row[4],
            priority=row[5],
            error_category=row[6],
            error_message=row[7],
            stack_trace=row[8],
            http_status=row[9],
            total_attempts=row[10],
            first_attempt_at=row[11],
            last_attempt_at=row[12],
            added_to_dlq_at=row[13],
            retry_attempted=row[14],
            retry_attempted_at=row[15],
            retry_success=row[16],
            resolved_at=row[17],
            resolution_notes=row[18],
        )

    async def mark_dlq_retry_attempted(self, *, id: int, retry_success: Optional[bool]) -> Optional[models.DeadLetterQueue]:
        row = (await self._conn.execute(sqlalchemy.text(MARK_DLQ_RETRY_ATTEMPTED), {"p1": id, "p2": retry_success})).first()
        if row is None:
            return None
        return models.DeadLetterQueue(
            id=row[0],
            job_id=row[1],
            seed_url=row[2],
            website_id=row[3],
            job_type=row[4],
            priority=row[5],
            error_category=row[6],
            error_message=row[7],
            stack_trace=row[8],
            http_status=row[9],
            total_attempts=row[10],
            first_attempt_at=row[11],
            last_attempt_at=row[12],
            added_to_dlq_at=row[13],
            retry_attempted=row[14],
            retry_attempted_at=row[15],
            retry_success=row[16],
            resolved_at=row[17],
            resolution_notes=row[18],
        )
