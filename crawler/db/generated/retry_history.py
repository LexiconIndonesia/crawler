# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: retry_history.sql
import datetime
import pydantic
from typing import AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


COUNT_RETRY_ATTEMPTS_BY_CATEGORY = """-- name: count_retry_attempts_by_category \\:many
SELECT
    error_category,
    COUNT(*) as total_attempts,
    COUNT(DISTINCT job_id) as unique_jobs
FROM retry_history
WHERE attempted_at >= :p1
GROUP BY error_category
ORDER BY total_attempts DESC
"""


class CountRetryAttemptsByCategoryRow(pydantic.BaseModel):
    error_category: models.ErrorCategoryEnum
    total_attempts: int
    unique_jobs: int


CREATE_RETRY_HISTORY = """-- name: create_retry_history \\:one
INSERT INTO retry_history (
    job_id,
    attempt_number,
    error_category,
    error_message,
    stack_trace,
    retry_delay_seconds
) VALUES (
    :p1, :p2, :p3, :p4, :p5, :p6
) RETURNING id, job_id, attempt_number, error_category, error_message, stack_trace, retry_delay_seconds, attempted_at
"""


GET_FAILURE_RATE_BY_CATEGORY = """-- name: get_failure_rate_by_category \\:many
SELECT
    error_category,
    COUNT(*) as failure_count,
    AVG(retry_delay_seconds) as avg_delay_seconds
FROM retry_history
WHERE attempted_at >= :p1 AND attempted_at < :p2
GROUP BY error_category
ORDER BY failure_count DESC
"""


class GetFailureRateByCategoryRow(pydantic.BaseModel):
    error_category: models.ErrorCategoryEnum
    failure_count: int
    avg_delay_seconds: float


GET_LATEST_RETRY_ATTEMPT = """-- name: get_latest_retry_attempt \\:one
SELECT id, job_id, attempt_number, error_category, error_message, stack_trace, retry_delay_seconds, attempted_at FROM retry_history
WHERE job_id = :p1
ORDER BY attempted_at DESC, attempt_number DESC
LIMIT 1
"""


GET_RETRY_HISTORY_BY_JOB_ID = """-- name: get_retry_history_by_job_id \\:many
SELECT id, job_id, attempt_number, error_category, error_message, stack_trace, retry_delay_seconds, attempted_at FROM retry_history
WHERE job_id = :p1
ORDER BY attempt_number ASC
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def count_retry_attempts_by_category(self, *, attempted_at: datetime.datetime) -> AsyncIterator[CountRetryAttemptsByCategoryRow]:
        result = await self._conn.stream(sqlalchemy.text(COUNT_RETRY_ATTEMPTS_BY_CATEGORY), {"p1": attempted_at})
        async for row in result:
            yield CountRetryAttemptsByCategoryRow(
                error_category=row[0],
                total_attempts=row[1],
                unique_jobs=row[2],
            )

    async def create_retry_history(self, *, job_id: uuid.UUID, attempt_number: int, error_category: models.ErrorCategoryEnum, error_message: str, stack_trace: Optional[str], retry_delay_seconds: int) -> Optional[models.RetryHistory]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_RETRY_HISTORY), {
            "p1": job_id,
            "p2": attempt_number,
            "p3": error_category,
            "p4": error_message,
            "p5": stack_trace,
            "p6": retry_delay_seconds,
        })).first()
        if row is None:
            return None
        return models.RetryHistory(
            id=row[0],
            job_id=row[1],
            attempt_number=row[2],
            error_category=row[3],
            error_message=row[4],
            stack_trace=row[5],
            retry_delay_seconds=row[6],
            attempted_at=row[7],
        )

    async def get_failure_rate_by_category(self, *, start_time: datetime.datetime, end_time: datetime.datetime) -> AsyncIterator[GetFailureRateByCategoryRow]:
        result = await self._conn.stream(sqlalchemy.text(GET_FAILURE_RATE_BY_CATEGORY), {"p1": start_time, "p2": end_time})
        async for row in result:
            yield GetFailureRateByCategoryRow(
                error_category=row[0],
                failure_count=row[1],
                avg_delay_seconds=row[2],
            )

    async def get_latest_retry_attempt(self, *, job_id: uuid.UUID) -> Optional[models.RetryHistory]:
        row = (await self._conn.execute(sqlalchemy.text(GET_LATEST_RETRY_ATTEMPT), {"p1": job_id})).first()
        if row is None:
            return None
        return models.RetryHistory(
            id=row[0],
            job_id=row[1],
            attempt_number=row[2],
            error_category=row[3],
            error_message=row[4],
            stack_trace=row[5],
            retry_delay_seconds=row[6],
            attempted_at=row[7],
        )

    async def get_retry_history_by_job_id(self, *, job_id: uuid.UUID) -> AsyncIterator[models.RetryHistory]:
        result = await self._conn.stream(sqlalchemy.text(GET_RETRY_HISTORY_BY_JOB_ID), {"p1": job_id})
        async for row in result:
            yield models.RetryHistory(
                id=row[0],
                job_id=row[1],
                attempt_number=row[2],
                error_category=row[3],
                error_message=row[4],
                stack_trace=row[5],
                retry_delay_seconds=row[6],
                attempted_at=row[7],
            )
