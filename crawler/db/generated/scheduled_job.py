# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.30.0
# source: scheduled_job.sql
import datetime
from typing import Any, AsyncIterator, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from crawler.db.generated import models


COUNT_SCHEDULED_JOBS = """-- name: count_scheduled_jobs \\:one
SELECT COUNT(*) FROM scheduled_job
WHERE website_id = COALESCE(:p1, website_id)
  AND is_active = COALESCE(:p2, is_active)
"""


CREATE_SCHEDULED_JOB = """-- name: create_scheduled_job \\:one
INSERT INTO scheduled_job (
    website_id,
    cron_schedule,
    next_run_time,
    is_active,
    job_config
) VALUES (
    :p1,
    :p2,
    :p3,
    COALESCE(:p4, true),
    :p5
)
RETURNING id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at
"""


DELETE_SCHEDULED_JOB = """-- name: delete_scheduled_job \\:exec
DELETE FROM scheduled_job
WHERE id = :p1
"""


GET_JOBS_DUE_FOR_EXECUTION = """-- name: get_jobs_due_for_execution \\:many
SELECT id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at FROM scheduled_job
WHERE is_active = true
  AND next_run_time <= :p1
ORDER BY next_run_time ASC
LIMIT :p2
"""


GET_SCHEDULED_JOB_BY_ID = """-- name: get_scheduled_job_by_id \\:one
SELECT id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at FROM scheduled_job
WHERE id = :p1
"""


GET_SCHEDULED_JOBS_BY_WEBSITE_ID = """-- name: get_scheduled_jobs_by_website_id \\:many
SELECT id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at FROM scheduled_job
WHERE website_id = :p1
ORDER BY created_at DESC
"""


LIST_ACTIVE_SCHEDULED_JOBS = """-- name: list_active_scheduled_jobs \\:many
SELECT id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at FROM scheduled_job
WHERE is_active = true
ORDER BY next_run_time ASC
LIMIT :p2 OFFSET :p1
"""


TOGGLE_SCHEDULED_JOB_STATUS = """-- name: toggle_scheduled_job_status \\:one
UPDATE scheduled_job
SET
    is_active = :p1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p2
RETURNING id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at
"""


UPDATE_SCHEDULED_JOB = """-- name: update_scheduled_job \\:one
UPDATE scheduled_job
SET
    cron_schedule = COALESCE(:p1, cron_schedule),
    next_run_time = COALESCE(:p2, next_run_time),
    last_run_time = COALESCE(:p3, last_run_time),
    is_active = COALESCE(:p4, is_active),
    job_config = COALESCE(:p5, job_config),
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p6
RETURNING id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at
"""


UPDATE_SCHEDULED_JOB_NEXT_RUN = """-- name: update_scheduled_job_next_run \\:one
UPDATE scheduled_job
SET
    next_run_time = :p1,
    last_run_time = :p2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p3
RETURNING id, website_id, cron_schedule, next_run_time, last_run_time, is_active, job_config, created_at, updated_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def count_scheduled_jobs(self, *, website_id: uuid.UUID, is_active: bool) -> Optional[int]:
        row = (await self._conn.execute(sqlalchemy.text(COUNT_SCHEDULED_JOBS), {"p1": website_id, "p2": is_active})).first()
        if row is None:
            return None
        return row[0]

    async def create_scheduled_job(self, *, website_id: uuid.UUID, cron_schedule: str, next_run_time: datetime.datetime, is_active: Optional[Any], job_config: Optional[Any]) -> Optional[models.ScheduledJob]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_SCHEDULED_JOB), {
            "p1": website_id,
            "p2": cron_schedule,
            "p3": next_run_time,
            "p4": is_active,
            "p5": job_config,
        })).first()
        if row is None:
            return None
        return models.ScheduledJob(
            id=row[0],
            website_id=row[1],
            cron_schedule=row[2],
            next_run_time=row[3],
            last_run_time=row[4],
            is_active=row[5],
            job_config=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def delete_scheduled_job(self, *, id: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_SCHEDULED_JOB), {"p1": id})

    async def get_jobs_due_for_execution(self, *, cutoff_time: datetime.datetime, limit_count: int) -> AsyncIterator[models.ScheduledJob]:
        result = await self._conn.stream(sqlalchemy.text(GET_JOBS_DUE_FOR_EXECUTION), {"p1": cutoff_time, "p2": limit_count})
        async for row in result:
            yield models.ScheduledJob(
                id=row[0],
                website_id=row[1],
                cron_schedule=row[2],
                next_run_time=row[3],
                last_run_time=row[4],
                is_active=row[5],
                job_config=row[6],
                created_at=row[7],
                updated_at=row[8],
            )

    async def get_scheduled_job_by_id(self, *, id: uuid.UUID) -> Optional[models.ScheduledJob]:
        row = (await self._conn.execute(sqlalchemy.text(GET_SCHEDULED_JOB_BY_ID), {"p1": id})).first()
        if row is None:
            return None
        return models.ScheduledJob(
            id=row[0],
            website_id=row[1],
            cron_schedule=row[2],
            next_run_time=row[3],
            last_run_time=row[4],
            is_active=row[5],
            job_config=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def get_scheduled_jobs_by_website_id(self, *, website_id: uuid.UUID) -> AsyncIterator[models.ScheduledJob]:
        result = await self._conn.stream(sqlalchemy.text(GET_SCHEDULED_JOBS_BY_WEBSITE_ID), {"p1": website_id})
        async for row in result:
            yield models.ScheduledJob(
                id=row[0],
                website_id=row[1],
                cron_schedule=row[2],
                next_run_time=row[3],
                last_run_time=row[4],
                is_active=row[5],
                job_config=row[6],
                created_at=row[7],
                updated_at=row[8],
            )

    async def list_active_scheduled_jobs(self, *, offset_count: int, limit_count: int) -> AsyncIterator[models.ScheduledJob]:
        result = await self._conn.stream(sqlalchemy.text(LIST_ACTIVE_SCHEDULED_JOBS), {"p1": offset_count, "p2": limit_count})
        async for row in result:
            yield models.ScheduledJob(
                id=row[0],
                website_id=row[1],
                cron_schedule=row[2],
                next_run_time=row[3],
                last_run_time=row[4],
                is_active=row[5],
                job_config=row[6],
                created_at=row[7],
                updated_at=row[8],
            )

    async def toggle_scheduled_job_status(self, *, is_active: bool, id: uuid.UUID) -> Optional[models.ScheduledJob]:
        row = (await self._conn.execute(sqlalchemy.text(TOGGLE_SCHEDULED_JOB_STATUS), {"p1": is_active, "p2": id})).first()
        if row is None:
            return None
        return models.ScheduledJob(
            id=row[0],
            website_id=row[1],
            cron_schedule=row[2],
            next_run_time=row[3],
            last_run_time=row[4],
            is_active=row[5],
            job_config=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def update_scheduled_job(self, *, cron_schedule: str, next_run_time: datetime.datetime, last_run_time: Optional[datetime.datetime], is_active: bool, job_config: Optional[Any], id: uuid.UUID) -> Optional[models.ScheduledJob]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_SCHEDULED_JOB), {
            "p1": cron_schedule,
            "p2": next_run_time,
            "p3": last_run_time,
            "p4": is_active,
            "p5": job_config,
            "p6": id,
        })).first()
        if row is None:
            return None
        return models.ScheduledJob(
            id=row[0],
            website_id=row[1],
            cron_schedule=row[2],
            next_run_time=row[3],
            last_run_time=row[4],
            is_active=row[5],
            job_config=row[6],
            created_at=row[7],
            updated_at=row[8],
        )

    async def update_scheduled_job_next_run(self, *, next_run_time: datetime.datetime, last_run_time: Optional[datetime.datetime], id: uuid.UUID) -> Optional[models.ScheduledJob]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_SCHEDULED_JOB_NEXT_RUN), {"p1": next_run_time, "p2": last_run_time, "p3": id})).first()
        if row is None:
            return None
        return models.ScheduledJob(
            id=row[0],
            website_id=row[1],
            cron_schedule=row[2],
            next_run_time=row[3],
            last_run_time=row[4],
            is_active=row[5],
            job_config=row[6],
            created_at=row[7],
            updated_at=row[8],
        )
